<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<META NAME="generator" CONTENT="http://txt2tags.org">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<LINK REL="stylesheet" TYPE="text/css" HREF="inc/site.css">
<TITLE>Les Disques</TITLE>
</HEAD>
<BODY>

<DIV CLASS="header" ID="header">
<H1>Les Disques</H1>
</DIV>

<DIV CLASS="body" ID="body">
<DIV CLASS="toc">

  <UL>
  <LI><A HREF="#disque">Quelques définitions</A>
  <LI><A HREF="#partition">Les Partitions</A>
    <UL>
    <LI><A HREF="#toc3">Principes</A>
    <LI><A HREF="#toc4">A la mode Microsoft</A>
    <LI><A HREF="#toc5">The Unix Way</A>
    <LI><A HREF="#toc6">Pourquoi partitionner?</A>
    <LI><A HREF="#toc7">Un partitionnement classique</A>
      <UL>
      <LI><A HREF="#toc8">Autres partitionements</A>
      </UL>
    </UL>
  <LI><A HREF="#format">Les systèmes de fichiers</A>
    <UL>
    <LI><A HREF="#toc10">Généralités</A>
      <UL>
      <LI><A HREF="#toc11">Format de partition</A>
      <LI><A HREF="#mbr">La table de partitionnement</A>
      </UL>
    <LI><A HREF="#toc13">Les principaux formats</A>
      <UL>
      <LI><A HREF="#ext">Le format ext (ext2, ext3, ext4)</A>
      <LI><A HREF="#swap">SWAP</A>
      <LI><A HREF="#toc16">Fat et Ntfs</A>
      </UL>
    </UL>
  <LI><A HREF="#toc17">Les différents types de fichiers</A>
    <UL>
    <LI><A HREF="#toc18">/boot</A>
    <LI><A HREF="#toc19">/bin</A>
    <LI><A HREF="#toc20">/dev</A>
    <LI><A HREF="#toc21">/etc</A>
    <LI><A HREF="#toc22">/lib</A>
    <LI><A HREF="#toc23">/mnt</A>
    <LI><A HREF="#toc24">/proc</A>
    <LI><A HREF="#toc25">/root</A>
    <LI><A HREF="#toc26">/tmp</A>
    <LI><A HREF="#toc27">/srv</A>
    <LI><A HREF="#toc28">/sys</A>
    <LI><A HREF="#toc29">/usr</A>
    <LI><A HREF="#toc30">/var</A>
    </UL>
  </UL>

</DIV>

<A NAME="disque"></A>
<H1>Quelques définitions</H1>

<DL>
<DT>Fichier</DT><DD>
Des <A HREF="01_hardware.php#vocab">données</A> auxquelles on peut avoir accès dans un système de fichiers
<P></P>
<DT>Dossier</DT><DD>
Ce qui nous permet de classer et de ranger ces fichiers
<P></P>
<DT>Arborescence</DT><DD>
Structure de dossiers imbriqués les uns à l'intérieur des autres
</DL>

<P>
<U>Le terme « système de fichier » peut être compris de deux façons différentes:</U>
</P>

<UL>
<LI>Un ensemble de fichiers et de dossiers réunis sous la forme d'un disque (ou d'une <A HREF="07_disks.php#partition">partition</A> de disque)
<LI>Un ensemble de <A HREF="07_disks.php#partititxt2tagson">partitions</A> et de disques, présentés par le <A HREF="04_software.php#os">système d'exploitation</A> sous la forme d'une <A HREF="07_disks.php#arbo">arborescence</A> globale
</UL>

<P>
La confusion vient du fait que le disque, avant qu'il ne soit branché sur votre ordinateur est <B>UN</B> système de fichier (le système de fichier du disque, de la partition, son <I>format</I> dit on aussi maladroitement)....
</P>
<P>
A l'inverse, le disque (une fois correctement installé/branché/monté), s'intègre dans <B>LE</B> système de fichier de votre ordinateur (celui que présente votre système d'exploitation)
</P>
<P>
L'homonymie fonctionne pareil en anglais (filesystem), alors faites attention!
</P>

<A NAME="partition"></A>
<H1>Les Partitions</H1>

<A NAME="toc3"></A>
<H2>Principes</H2>

<P>
Partitionner un <A HREF="07_disks.php#disque">disque dur</A> , c'est schématiquement, le découper, pour recréer virtuellement le fonctionnement de plusieurs disques.
</P>
<P>
Mais cela permet aussi à l'inverse de rassembler plusieurs <A HREF="07_disks.php#partititxt2tagson">partitions</A> (ou plusieurs disques) en un seul disque virtuel. <I>(et c'est franchement pas commun pour un ordinateur personnel)</I>
</P>

<A NAME="toc4"></A>
<H2>A la mode Microsoft</H2>

<P>
Les utilisateurs de Windows sont généralement habitués à ce que chacun de leur <A HREF="07_disks.php#disque">disque dur</A>  soit représenté de façon unique et équivoque, sous la petite icône " ordinateur " ou " poste de travail"!
</P>
<P>
Sous Windows chaque <A HREF="07_disks.php#partition">partition</A> d'un disque se voit attribuer une lettre. La <A HREF="07_disks.php#partition">partition</A> sur laquelle sont enregistrés les fichiers nécessaires au fonctionnement du <A HREF="04_software.php#os">système d'exploitation</A> Windows sont souvent sur le lecteur C:\. Les <A HREF="07_disks.php#partititxt2tagson">partitions</A> des différents <A HREF="07_disks.php#disque">disques durs</A>  (et les lecteurs amovibles, lecteur CD, clé USB...) prennent les lettres suivantes. À l'intérieur d'un <A HREF="07_disks.php#disque">disque dur</A>  on peut créer une <A HREF="07_disks.php#arbo">arborescence</A> de fichiers et de dossiers.
</P>
<P>
Toutefois, si l'on remonte au répertoire parent jusqu'en haut, alors, on aboutit à un moment singulier, on arrive dans "l'ordinateur", le "poste de travail". Quand vous êtes précisément dans votre poste de travail, vous ne pouvez pas créer de dossiers à cet endroit là. Vous n'êtes pas dans un véritable dossier, vous êtes dans un <A HREF="04_software.php#intro">programme</A> qui vous donne accès aux différents lecteurs. Windows présente donc chaque lecteur comme une <A HREF="07_disks.php#arbo">arborescence</A> séparée des autres.
</P>

<A NAME="toc5"></A>
<H2>The Unix Way</H2>

<P>
Sous Linux, vous avez une première <A HREF="07_disks.php#partition">partition</A> qui est la <A HREF="07_disks.php#partition">partition</A> racine (<CODE>/</CODE>). Elle est le sommet de l'arborescence (comme le Poste De Travail), mais elle est aussi une <A HREF="07_disks.php#partition">partition</A> tout à fait ordinaire. (même si elle contient des fichiers importants)
</P>
<P>
Et c'est à l'intérieur de cette partition, que vous créez des dossiers dans lesquels apparaitrons vos autres partitions...
</P>
<P>
Sous Linux, il n'existe donc qu'une seule <A HREF="07_disks.php#arbo">arborescence,</A> et vous décidez de l'endroit où vous <B>montez</B> vos <A HREF="07_disks.php#partititxt2tagson">partitions</A> à l'intérieur de celle-ci... Cela est beaucoup plus astucieux car on peut ainsi rajouter de l'espace disque à une <A HREF="07_disks.php#partition">partition</A> saturée en <B>montant</B> un nouveau disque à l'intérieur de celle-ci.
</P>

<A NAME="toc6"></A>
<H2>Pourquoi partitionner?</H2>

<P>
Sous Gnu-Linux on privilégiera une installation sur plusieurs partitions.
</P>
<P>
C'est comme si Windows insistait pendant son installation pour que votre répertoire "Mes Documents" votre "Bureau" et toute votre configuration ne soit surtout pas sur le même disque que lui... (gentil !)
</P>

<A NAME="toc7"></A>
<H2>Un partitionnement classique</H2>

<P>
Un schéma de partitionnement classique pour les ordinateurs de bureau, serait le suivant :
</P>

<UL>
<LI>une <A HREF="07_disks.php#partition">partition</A> racine pour le <A HREF="04_software.php#os">système d'exploitation</A> (<CODE>/</CODE>)
<LI>une <A HREF="07_disks.php#partition">partition</A> <A HREF="07_disks.php#swap">SWAP</A> pour les fichiers temporaires
<LI>une <A HREF="07_disks.php#partition">partition</A> pour les <A HREF="01_hardware.php#vocab">données</A> de l'utilisateur et ses fichiers de configuration. (<CODE>/home</CODE>)
</UL>

<P>
Ce schéma de partitionnement à l'avantage de séparer les <A HREF="01_hardware.php#vocab">données</A> de l'utilisateur de la <A HREF="07_disks.php#partition">partition</A> se trouve le système d'exploitation. En cas d'un crash système d'exploitation, si ce dernier se retrouve inutilisable, on pourra effacer tout le contenu de la <A HREF="07_disks.php#partition">partition</A> qui le contient... sans se poser de questions!
</P>
<P>
On pourra ensuite réinstaller un <A HREF="04_software.php#os">système d'exploitation</A> dessus. On remontera la <A HREF="07_disks.php#partition">partition</A> des utilisateurs au même endroit, et ces derniers n'auront rien vu (ils retrouverons leur configuration).
</P>

<A NAME="toc8"></A>
<H3>Autres partitionements</H3>

<P>
Une <A HREF="07_disks.php#partition">partition</A> de sauvegarde de vos fichiers (pas la <CODE>/home</CODE> mais plutôt <CODE>/home/nono/SAUVEGARDE</CODE> ou pour la mettre un peu à l'écart <CODE>/sauvegardes</CODE>) peut vous sauver la mise parfois (Éventuellement dans un format lisible depuis Windows...).
</P>
<P>
Dans le cas d'un multi-boot avec Windows, et si votre bios fonctionne en Uefi, vous aurez besoin d'une <A HREF="07_disks.php#partition">partition</A> Efi.
</P>
<P>
On peut également vouloir créer des <A HREF="07_disks.php#partititxt2tagson">partitions</A> pour d'autres dossiers comme <CODE>/etc</CODE> pour restaurer aussi la configuration globale du système d'exploitation! Mais si vous n'installez pas la même <A HREF="08_libre.php#distrib">distribution</A> de Gnu-Linux pour votre prochaine installation, il faudra faire le ménage! (fichiers devenus inutiles, config incompatibles avec la nouvelle distribution...) Aussi, au début, on préfèrera le limiter à des schémas classiques, et sauvegarder les fichiers de configuration que l'on connait, ou qu'on a modifié soi même. Plus vous serez à l'aise avec les <A HREF="07_disks.php#partititxt2tagson">partitions</A> et les différents dossiers de l'arborescence, plus vous personnaliserez en fonction de vos gout et de votre configuration matérielle.
</P>

<A NAME="format"></A>
<H1>Les systèmes de fichiers</H1>

<A NAME="toc10"></A>
<H2>Généralités</H2>

<P>
Un <A HREF="07_disks.php#disque">disque dur</A>  n'est rien qu'un grand espace dans lequel vous pouvez écrire de ZÉROs et des UN. C'est le système de fichier qui permet de lui donner une structure, et qui nous le fait apparaitre comme des fichiers organisés dans une <A HREF="07_disks.php#arbo">arborescence</A> de dossiers... Mais le disque en lui même ne contient ni case, ni index.
</P>
<P>
Pour bien faire la différence entre le système de fichier et le système de fichiers (introduction) car après on s'y perd...
</P>
<P>
Je dirais L'ARBORESCENCE pour parler <B>du tout</B> (l'arborescence hiérarchique composée de plein <A HREF="07_disks.php#partition">partition</A> de plein de disque et plus encore que nous présente le système d'exploitation).
</P>
<P>
Les autres termes sont synonymes! Pour une fois qu'en français, notre langue fourche pour ne pas dire le même mot pour deux choses différentes, et que c'est plus précis que la bonne terminologie, on ne va pas s'en priver...
</P>
<P>
On utilise la commande <CODE>mount</CODE> pour monter les <A HREF="07_disks.php#partititxt2tagson">partitions</A> sur la hiérarchie des dossiers.
</P>
<P>
Au démarrage le <A HREF="02_boot.php#kernel">noyau</A> monte la <A HREF="07_disks.php#partition">partition</A> root au sommet de l'arborescence mais en lecture seulement. La commande <CODE>fsck</CODE> est utilisée pour vérifier que le disque n'a pas été endommagé. Ensuite seulement, le <A HREF="02_boot.php#kernel">noyau</A> remonte la <A HREF="07_disks.php#partition">partition</A> racine en lecture/écriture.
</P>

<A NAME="toc11"></A>
<H3>Format de partition</H3>

<P>
Le système de fichier est ce qui définit comment l'ordinateur doit consigner les <A HREF="01_hardware.php#vocab">données</A> (comment séparer la fin d'un fichier du début du prochain, ou se situe l'index...)
</P>
<P>
Chaque système de fichier présente des avantages et inconvénients. Certains n'autorisent pas les noms de fichier de plus de 12 caractères, mais sont redoutablement rapides! D'autres vous permettent d'effectuer des sauvegarde automatique de votre système et de pouvoir le restaurer <B>exactement</B> tel qu'il était à une date donnée... Certains sont optimisés pour certains matériels (carte sd, disque-dur, ssd), il y en a de nombreux! Certains ont besoin d'une défragmentation régulière pour survivre...
</P>
<P>
Windows sait lire les <A HREF="07_disks.php#partititxt2tagson">partitions</A> au format Fat32 et Ntfs (J'exclue certes cd, dvd, et autres disques en lecture seule). <A HREF="02_boot.php#bios">Linux</A> sait lire des dizaines de formats.
</P>

<A NAME="mbr"></A>
<H3>La table de partitionnement</H3>

<P>
Une section immédiatement au début de chaque disque est normalisée, elle contient la table de partitionnement. Celle-ci décrit le nombre de partitions, leur taille, leur format et leurs places respectives sur le disque.
</P>
<P>
C'est un secteur réservé, et aucun <A HREF="04_software.php#intro">programme</A> n'est supposé y toucher excepté le gestionnaire de démarrage, et les logiciels de partitionnement (et <CODE>dd</CODE> bien sûr).
</P>
<P>
Durant presque trente ans, jusqu'en 2005 environ, les tables de <A HREF="07_disks.php#partition">partition</A> étaient au format MBR, ce dernier impose quelques limitations comme:
</P>

<UL>
<LI>pas plus de 4 <A HREF="07_disks.php#partititxt2tagson">partitions</A> primaires et pour avoir un nombre de <A HREF="07_disks.php#partititxt2tagson">partitions</A> supérieur on devait
<LI>créer une <A HREF="07_disks.php#partition">partition</A> primaire de type étendue et créer des sous <A HREF="07_disks.php#partition">partition</A> à l'intérieur de celle ci
<LI>Pas la possibilité d'adresser plus de 2 tera-octet de disque
</UL>

<P>
Les nouvelles tables de <A HREF="07_disks.php#partition">partition</A> GPT on des limitations beaucoup plus larges (96 <A HREF="07_disks.php#partititxt2tagson">partitions</A> par disque)
</P>
<P>
Si votre carte mère possède un Micrologiciel BIOS, elle s'attend <I>surement</I> à une table de <A HREF="07_disks.php#partition">partition</A> MBR
Si votre carte mère possède un Micrologiciel UEFI, elle s'attend à une table de <A HREF="07_disks.php#partition">partition</A> GPT.
</P>
<P>
Faites attention avec les logiciels de partitionnement! Mal les utiliser peut conduire à une destruction de toutes vos données.
</P>

<A NAME="toc13"></A>
<H2>Les principaux formats</H2>

<P>
Ce qui est à peu près commun pour tous les systèmes de fichier, c'est qu'il découpent l'espace du disque en adresses, et qu'il identifient les fichiers par des inodes, et que ces inodes décrivent les fichiers et les informations qui leur sont relatives.
</P>
<P>
Les dossiers sont eux aussi représentés sous la formes d'inodes, et contiennent en plus la liste des inodes des fichiers qu'ils contiennent.
</P>
<P>
Quand le <A HREF="04_software.php#os">système d'exploitation</A> essaie de lire <CODE>/home/nono/grololo.jpeg</CODE>. Il cherche d'abord l'inode de <CODE>/</CODE> qui lui fournit l'inode de <CODE>/home</CODE>, qui lui fournit l'inode de <CODE>grololo.jpeg</CODE> qui indique enfin à quelle adresse du disque trouver la ressource.
</P>
<P>
Si l'on ajoute des <A HREF="01_hardware.php#vocab">données</A> sur un disque, il peut arriver que les <A HREF="01_hardware.php#vocab">données</A> soient écrites avant que l'inode n'ait été mis à jour. Si le courant coupe au mauvais moment, perdre un inode, c'est parfois perdre un répertoire majeur de l'arborescence! Ce problème a mené à l'invention des systèmes de fichier journalisés.
</P>

<A NAME="ext"></A>
<H3>Le format ext (ext2, ext3, ext4)</H3>

<P>
Dans ce format, l'inode, de chaque fichier indique:
</P>

<UL>
<LI>l'utilisateur propriétaire du fichier
<LI>les droits de lecture/écriture/exécution de l'utilisateur propriétaire
<LI>le groupe propriétaire du fichier
<LI>les droits de lecture/écriture/exécution du groupe propriétaire
<LI>les droits de lecture/écriture/exécution pour tous les autres utilisateurs
<LI>les dates de dernier accès,de dernière modification, de création.
<LI>les attributs....
<LI>j'oublie quelque chose?
</UL>

<P>
C'est un système de fichier qui n'a pas besoin de défragmentation, et il est journalisé depuis la version 3.
</P>
<P>
C'est un système de fichier créé pour Gnu-Linux. D'autres formats ne lui permettrait pas de déployer tout son potentiel. En effet, tous les formats ne permettent pas de définir des droit d'accès par utilisateur et par groupe au niveau de chaque fichier, et chaque répertoire....
</P>
<P>
On peut aussi donner des attributs au fichiers et aux répertoires comme:
</P>

<UL>
<LI>interdire à l'écriture même par le propriétaire
<LI>interdire de modifier un fichier tout en ayant le droit d'écrire à sa suite comme un journal de bord...)
<LI>créer des fichiers spéciaux... (suspens!)
</UL>

<P>
Le fait de pouvoir définir des droits d'accès spécifiques fichiers par fichiers est un des point fondamental de la gestion de la sécurité sous Gnu-Linux. Nous reverrons plus loin comment l'on gère ces attributs.
</P>

<A NAME="swap"></A>
<H3>SWAP</H3>

<P>
Sous les environnements Windows, on dit que la mémoire est libre quand elle n'est utilisée par aucune application. Les applications réclament de l'espace mémoire, Windows leur alloue une partie de cet espace, et quand l'espace est entièrement saturé, Windows utilise un fichier qu'il appelle « le fichier d'échange » dans lequel il se défausse d'une partie de la mémoire. Le fichier d'échange est ainsi beaucoup moins rapide que la mémoire vive.
</P>
<P>
Sous Linux, on fait la différence entre la mémoire disponible et la mémoire libre. Le <A HREF="04_software.php#os">système d'exploitation</A> considère que de l'espace mémoire non utilisé est un gâchis. Si la mémoire vient à manquer, le système n'a pas un fichier particulier dans lequel se défausser.
</P>
<P>
En effet sous Gnu-Linux, on prévoit une <A HREF="07_disks.php#partition">partition</A> entièrement dédiée à cela. On appelle cette <A HREF="07_disks.php#partition">partition</A> la swap. Elle est formatée à chaque démarrage. Son format de fichier est optimisé pour les écritures réécritures fréquentes. C'est le seul type de <A HREF="07_disks.php#partition">partition</A> que vous ne pouvez pas monter dans l'arborescence.
</P>
<P>
C'est aussi à cet endroit que le système copiera la mémoire sur le disque en cas d'hibernation/mise en veille prolongée! Ainsi elle doit toujours être au moins de la taille de la ram.
</P>

<A NAME="toc16"></A>
<H3>Fat et Ntfs</H3>

<P>
Vous n'avez pas le choix si vous voulez que Microsoft Windows lise un disque-dure, ce sera l'un de ces deux formats que vous devrez utiliser.
</P>
<P>
Fat16 est archaïque. Fat32 a l'avantage d'être très lisible notamment pour les appareil vidéos et les clefs usb, mais il n'est pas journalisé. On doit absolument démonter le disque avant de le retirer, (« Retirer le <A HREF="01_hardware.php#periph">périphérique</A> » çà vous dit quelque chose?)
</P>
<P>
Pas de disque de plus de 2 tera-octets, ni de fichier de plus de 4 giga-octet en Fat32.
</P>
<P>
Ntfs est beaucoup moins limité, et il est journalisé.
</P>

<A NAME="toc17"></A>
<H1>Les différents types de fichiers</H1>

<P>
Il existe différents types de fichiers, pour une liste non exhaustive :
</P>

<OL>
<LI>Documents de l'utilisateur
<LI>Programme
<LI>Librairies
<LI>Fichiers temporaires ...
<LI>Fichier de configuration
<LI>Les fichiers spéciaux
<LI>Les liens
<P></P>
Nous n'allons pas détailler tout de suite,
<P></P>
=L'arborescence=[arbo]
</OL>

<P>
Tout part de la <A HREF="07_disks.php#partition">partition</A> racine, aussi appelée <A HREF="07_disks.php#partition">partition</A> root, la slash, (<CODE>/</CODE>). Celle ci contient un certain nombre de dossier et sous dossier, et un certain nombre de fichiers.
</P>
<P>
La Philosophie <A HREF="06_unix.php">Unix</A> veut que tout soit fichier, ainsi, écrire dans la mémoire vive, envoyer des <A HREF="01_hardware.php#vocab">données</A> sur un bus, vérifier l'état d'un périphérique, modifier la configuration, éteindre un périphérique, activer un service... tout ceci correspondra à des actions sur des fichiers.
</P>
<P>
Vous vous en doutez, l'arborescence de <A HREF="02_boot.php#bios">Linux</A> est une caverne au merveille, et on peut beaucoup apprendre en s'y promenant! Et, (vous vous en doutez aussi), l'arborescence contiendra ce que contiennent vos partitions, mais pas que...
</P>
<P>
Les différentes tentatives pour standardiser les choses à ce niveau ont donné peu de résultat, mais ici on ne regardera pas les sous-sous-sous-répertoires, donc, oubliez ce que je viens de dire! Et voici ce sur quoi il n'y a pas à discuter!
</P>

<A NAME="toc18"></A>
<H2>/boot</H2>

<P>
Ici se trouvent les noyaux, et ce qui est nécessaire pour l'exécution du chargeur de démarrage.
</P>

<A NAME="toc19"></A>
<H2>/bin</H2>

<P>
Binaries (exécutables), c'est ici que l'on trouve les applications (sans leur ressources, données, librairies...juste les exécutables)
</P>
<P>
En fait, souvent ce n'est pas un vrai répertoire, mais un lien vers <CODE>/usr/bin</CODE> (on va y venir)
</P>

<A NAME="toc20"></A>
<H2>/dev</H2>

<P>
Devices (périphérique), les fichiers qui se trouvent dans ce répertoire sont des fichiers spéciaux qui pointent vers des périphériques.
</P>
<P>
Les programmes peuvent donc communiquer avec le matériel soient par des appels système, soit en écrivant des <A HREF="01_hardware.php#vocab">données</A> brutes dans les fichiers du répertoire /dev.
</P>
<P>
Les fichiers qui commencent par <CODE>/dev/sd</CODE> sont les <B>DISQUES</B>. Il y a de fortes chance pour que votre <A HREF="07_disks.php#disque">disque dur</A>  de <A HREF="02_boot.php#boot">boot</A> soit en <CODE>/dev/sda</CODE>. Ils sont numérotés avec des lettres (<I>bizarre comme phrase</I>)
</P>
<P>
Les Fichiers qui commencent par <CODE>/dev/sdX</CODE> (ou X est une lettre minuscule suivie d'un chiffre) sont des <B>PARTITIONS</B> (votre <A HREF="07_disks.php#partition">partition</A> racine pourrait être par exemple <CODE>/dev/sda1</CODE>)
</P>

<A NAME="toc21"></A>
<H2>/etc</H2>

<P>
Oui oui oui, c'est le répertoire « et cætera»! Tous les fichiers qui ne rentraient pas dans un de ces autres dossier, mais qui étaient trop importants pour qu'on les perde.
</P>
<P>
C'est dans ce dossier que se trouvent tous les fichiers de configuration du système.
</P>

<A NAME="toc22"></A>
<H2>/lib</H2>

<P>
Les <A HREF="04_software.php#library">librairies</A> dont le système a besoin pour fonctionner.
</P>

<A NAME="toc23"></A>
<H2>/mnt</H2>

<P>
Un répertoire vide pour servir de point de montage temporaire.
</P>

<A NAME="toc24"></A>
<H2>/proc</H2>

<P>
C'est un système de fichier très particulier qui est monté en <CODE>/proc</CODE>. C'est véritablement la représentation que se fait le <A HREF="02_boot.php#kernel">noyau</A> de son environnement. Il contient un dossier pour chaque <A HREF="02_boot.php#kernel">processus</A> en cour d'exécution sur le système. (il faudrait parler des PID), ce dossier contient aussi le fichier <CODE>interrupts</CODE> et <CODE>meminfo</CODE> qui vous donneront des info sur l'utilisation du système. Il y a beaucoup à apprendre en explorant /proc.
</P>
<P>
C'est ce que l'on appelle un "pseudo-système de fichier".
</P>

<A NAME="toc25"></A>
<H2>/root</H2>

<P>
Le Super-utilisateur n'a pas son dossier personnel dans la /home, mais directement dans la <A HREF="07_disks.php#partition">partition</A> racine, ainsi lors d'une panne du système, il peut se connecter à son <A HREF="02_boot.php#shell">shell</A> correctement configuré, et avoir accès à ses fichiers.
</P>
<P>
Si vous allez faire quelque chose de dangereux, vous pouvez déconnecter tous les utilisateur, vous connecter en root, et démonter la <CODE>/home</CODE> et toutes les <A HREF="07_disks.php#partititxt2tagson">partitions</A> qui craignent quelque chose.
</P>

<A NAME="toc26"></A>
<H2>/tmp</H2>

<P>
Pour les fichiers temporaires. Si votre <A HREF="02_boot.php#init">gestionnaire d'initialisation</A> est Systemd, il aura surement monté un "tmpfs" à cet endroit.
</P>
<P>
C'est un autre "pseudo-système" qui imite une véritable <A HREF="07_disks.php#partition">partition</A> uniquement avec la mémoire vive. C'est bien plus rapide qu'un disque-dur, et utile pour les applications qui doivent constamment stocker une grosse quantité de <A HREF="01_hardware.php#vocab">données</A> (pensez au streaming!)
</P>

<A NAME="toc27"></A>
<H2>/srv</H2>

<P>
Pour les répertoires partagés sur Internet.
</P>

<A NAME="toc28"></A>
<H2>/sys</H2>

<P>
<CODE>/proc</CODE> nous offrait la possibilité de voir ce qu'il se passait dans le noyau. Cette fois ci, le <A HREF="02_boot.php#kernel">noyau</A> nous propose une interface pour communiquer avec lui et les différents périphériques, en manipulant les fichiers de ce pseudo système.
</P>

<A NAME="toc29"></A>
<H2>/usr</H2>

<P>
C'est un peu le "Program Files" de Gnu-Linux.
</P>
<P>
A la base, c'était le répertoire des dossiers utilisateurs, la <CODE>/home</CODE> de l'époque... Mais un jour au MIT, ils on eut des problèmes de stockage... Et ils on balancé <CODE>/bin, /lib, et les autres</CODE> ici!
</P>
<P>
Quand ils on eu un nouveau disque, ils ont déplacé le répertoire des utilisateurs dans <CODE>/home</CODE>, seul <CODE>/usr/share</CODE> (qui contient la documentation notamment) est resté en place. Depuis c'est comme çà, c'est historique!
</P>

<A NAME="toc30"></A>
<H2>/var</H2>

<P>
Des fichiers utiles mais pas indispensables. Les journaux de connections et autre journaux de surveillance du système. Une copie des paquetages que l'on installe...
</P>
<P>
Le carnet de maintenance en somme! Si vous ne voulez pas faire tournez un serveur, ou devenir agent secret, ne vous en souciez plus.
</P>

<HR NOSHADE SIZE=5>

<TABLE ALIGN="center" BORDER="1">
<TR>
<TD>PREC: <A HREF="06_unix.html">Unix...</A></TD>
<TD></TD>
<TD COLSPAN="2">SUIV: <A HREF="08_libre.html">La philosophie du Libre</A></TD>
</TR>
<TR>
<TD></TD>
<TD><A HREF="index.html">Menu Principal</A></TD>
<TD></TD>
</TR>
</TABLE>

<HR NOSHADE SIZE=5>

</DIV>
<!-- html code generated by txt2tags 2.6 (http://txt2tags.org) -->
<!-- cmdline: txt2tags 01_hardware.t2t.temp 02_boot.t2t.temp 03_interface.t2t.temp 04_software.t2t.temp 05_network.t2t.temp 06_unix.t2t.temp 07_disks.t2t.temp 08_libre.t2t.temp 09_shell.t2t.temp 10_console.t2t.temp 11_editor.t2t.temp 12_config.t2t.temp 13_help.t2t.temp 14_programming.t2t.temp 15_archlinux.t2t.temp 15_bashrc.t2t.temp author.t2t.temp bashrc_comment.t2t.temp index.t2t.temp roadmap.t2t.temp -->
</BODY></HTML>
-------------------------------------
Version Html, commentaires désactivés
-------------------------------------
