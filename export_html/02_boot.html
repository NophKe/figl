<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<META NAME="generator" CONTENT="http://txt2tags.org">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<LINK REL="stylesheet" TYPE="text/css" HREF="inc/site.css">
<TITLE>Le Boot</TITLE>
</HEAD>
<BODY>

<DIV CLASS="header" ID="header">
<H1>Le Boot</H1>
</DIV>

<DIV CLASS="body" ID="body">
<DIV CLASS="toc">

  <UL>
  <LI><A HREF="#boot">L'art d'enfiler ses chaussure</A>
  <LI><A HREF="#bios">Le Micrologiciel</A>
  <LI><A HREF="#kernel">Le rôle du noyau</A>
  <LI><A HREF="#grub">Le Chargeur de Démarrage</A>
  <LI><A HREF="#init">Le Gestionnaire d'initialisation</A>
    <UL>
    <LI><A HREF="#toc6">Init</A>
    <LI><A HREF="#systemd">Systemd</A>
      <UL>
      <LI><A HREF="#service">Les Services</A>
      <LI><A HREF="#target">Les Targets</A>
      <LI><A HREF="#target">Les Sockets</A>
      </UL>
    </UL>
  <LI><A HREF="#login">Login as user</A>
    <UL>
    <LI><A HREF="#toc12">Interface texte et interface graphique</A>
    <LI><A HREF="#user">Utilisateurs et groupes</A>
    <LI><A HREF="#auth">With great power comes great responsibility</A>
    </UL>
  <LI><A HREF="#connected">Une fois connecté?</A>
    <UL>
    <LI><A HREF="#gui">Les Interfaces graphiques</A>
      <UL>
      <LI><A HREF="#toc17">Pour ne citer que les principales (et mes préférés)</A>
      </UL>
    <LI><A HREF="#shell">Le Shell</A>
      <UL>
      <LI><A HREF="#toc19">Les différents shells</A>
      </UL>
    </UL>
  </UL>

</DIV>

<A NAME="boot"></A>
<H1>L'art d'enfiler ses chaussure</H1>

<P>
L'ordinateur est mis sous-tension, il s'allume! Dans une <B>puce électronique</B>, un <A HREF="04_software.php#intro">programme</A> (appelé le micro-logiciel) analyse l'ordinateur, trouve le/les <A HREF="07_disks.php#disque">disques durs</A> , lit le disque qui sera désigné comme disque de boot, et trouve un autre <A HREF="04_software.php#intro">programme</A> inscrit sur ce disque. Ce dernier, sur le disque, se nomme <B>le gestionnaire de démarrage</B>.
</P>
<P>
Le gestionnaire de démarrage (suivant comment il est configuré) vous propose un (ou plusieurs) noyaux, et un (ou plusieurs) système d'exploitation, voir encore une (ou plusieurs) options. Dans tous les cas, il lui faut charger le <A HREF="02_boot.php#kernel">noyau</A> d'un système d'exploitation.
</P>
<P>
Le <A HREF="02_boot.php#kernel">noyau</A> d'un système d'exploitation, c'est le <A HREF="04_software.php#intro">programme</A> qui sait communiquer avec le matériel qui constitue l'ordinateur. Le <A HREF="02_boot.php#kernel">noyau</A> n'est pas l'interface avec laquelle interagit l'utilisateur.
</P>
<P>
Le <A HREF="02_boot.php#kernel">noyau</A> met en place un environnement dont le but n'est que de masquer les détails techniques de l'architecture matérielle en place. C'est grâce à cet environnement que le couple <A HREF="04_software.php#intro">programme</A> et <A HREF="04_software.php#os">système d'exploitation</A> s'épanouit. Un <A HREF="04_software.php#intro">programme</A> qui fonctionne sur un <A HREF="04_software.php#os">système d'exploitation</A> fonctionnera toujours sur ce <A HREF="04_software.php#os">système d'exploitation</A> quelque soit la machine sur laquelle est installé ce <A HREF="04_software.php#os">système d'exploitation</A> (si c'est bien la même version).
</P>
<P>
C'est à l'intérieur de l'environnement créé par le <A HREF="02_boot.php#kernel">noyau</A> qu'on lance différents programmes pour réaliser différents <A HREF="02_boot.php#service">services</A> dont on aura besoin sur l'ordinateur. Le premier <A HREF="04_software.php#intro">programme</A> que lance le <A HREF="02_boot.php#kernel">noyau</A> est le <A HREF="02_boot.php#init">gestionnaire d'initialisation</A> qui va donc lire les fichiers de configuration à sa disposition, et lancer différents programmes nécessaires au fonctionnement de la machine.
</P>
<P>
Différents types de programmes vont donc démarrer, certains vont effectuer une simple action et se fermer d'eux-mêmes. Par exemple, à chaque démarrage <A HREF="02_boot.php#bios">Linux</A> vérifie l'intégrité de vos <A HREF="07_disks.php#disque">disques durs</A>  avec l'aide du <A HREF="04_software.php#intro">programme</A> <CODE>fsck</CODE>. S'il ne trouve pas de problème particulier, ce <A HREF="04_software.php#intro">programme</A> se ferme, et le démarrage continu.
</P>
<P>
D'autres programmes vont lancer leur initialisation, et éventuellement rester en tache de fond. C'est ce que l'on appelle les services, les <A HREF="02_boot.php#service">services</A> servent à plein de choses, un exemple simple pour s'en rendre compte et de penser à la clé USB que vous insérez dans votre ordinateur. Il faut bien qu'il y ait un <A HREF="04_software.php#intro">programme</A> en tache de fond qui scrute l'insertion d'une clé USB si vous voulez qu'il se passe quelque chose quand vous en insérez une.
</P>
<P>
Le dernier <A HREF="04_software.php#intro">programme</A> que lancera le <A HREF="02_boot.php#init">gestionnaire d'initialisation</A> sera le gestionnaire de connexion. C'est ce <A HREF="04_software.php#intro">programme</A> qui vous demande d'entrer votre mot de passe utilisateur lorsque vous connectez. Vous entrez donc votre nom d'utilisateur, votre mot de passe. Et vous obtenez l'interface utilisateur qui est le dernier <A HREF="04_software.php#intro">programme</A> qui sera lancé automatiquement.
</P>
<P>
L'ordinateur est initialisé, c'est au tour de l'utilisateur de continuer. Il peut lancer des programmes, et ajouter des services.
</P>
<P>
Réussir tout cela, et dans le bon ordre, c'est comme enfiler ses chaussure! Faut mettre la bonne au bonne endroit, les enfiler, les lacer! Ce <A HREF="02_boot.php#kernel">processus</A> en anglais, c'est le bootstrapping, <A HREF="02_boot.php#boot">boot</A> signifiant chaussure.
</P>
<P>
Aussi démarrer un ordinateur, c'est <I>booter</I>! (En bon fraçais ...)
</P>

<A NAME="bios"></A>
<H1>Le Micrologiciel</H1>

<HR NOSHADE SIZE=1>

<P>
On parle rarement de micro-logiciel, (et quelque soit son genre), on dira souvent BIOS par abus de langage. J'essaierai de ne pas trop le faire dans ce qui suit.
</P>

<HR NOSHADE SIZE=1>

<P>
Lorsque matériellement vous allumez votre ordinateur, le <A HREF="02_boot.php#bios">micro-logiciel</A> se charge de reconnaître la configuration matérielle de votre ordinateur. Il détecte s'il y a des <A HREF="07_disks.php#disque">disques durs</A>  de brancher, quelle est la quantité de mémoire quel est le type de processeur....
</P>
<P>
Ce premier <A HREF="04_software.php#intro">programme</A> c'est soit:
</P>

<UL>
<LI>soit un BIOS ( → Basic Input Output System / Le système élémentaire des entrées et sorties).
<LI>soit un UEFI ( → Unified Extensible Firmware Interface / Interface Matérielle Extensible Unifiée).
</UL>

<P>
Une interface de configuration du BIOS/UEFI, peut-être lancé en appuyant sur une touche (généralement F2) lors des premières secondes du démarrage de l'ordinateur.
</P>
<P>
<A HREF="https://fr.wikipedia.org/wiki/Basic_Input_Output_System"><IMG ALIGN="middle" SRC="img/bios.png" BORDER="0" ALT=""></A>
</P>

<TABLE ALIGN="center">
<TR>
<TD>Interface de configuration du bios ( credit Wikipedia)</TD>
</TR>
</TABLE>

<P>
Comme, un ordinateur sans un <A HREF="04_software.php#intro">programme</A> n'est qu'un inerte tas d'électronique. Les instructions de démarrage sont inscrites à l'intérieur du <A HREF="02_boot.php#bios">micro-logiciel</A> qui va rechercher à un emplacement déterminé, le bon programme. <I>(cet emplacement, c'est la table des partitions)</I>.
</P>
<P>
Dans cette table, le <A HREF="02_boot.php#bios">micro-logiciel</A> recherche l'adresse d'un <A HREF="04_software.php#intro">programme</A> appelé <A HREF="02_boot.php#boot">boot</A> loader, le <A HREF="02_boot.php#grub">chargeur de démarrage.</A> Une fois que le <A HREF="02_boot.php#grub">chargeur de démarrage</A> est placé dans la mémoire et démarré, celui-ci charge le véritable système d'exploitation.
</P>
<P>
Pourquoi le <A HREF="02_boot.php#bios">micro-logiciel</A> ne charge t il pas directement le système d'exploitation? La table des <A HREF="07_disks.php#partition">partition</A> MBR est un standard vieux de trente ans et ce genre de table des <A HREF="07_disks.php#partition">partition</A> ne nous permet pas de faire mieux que d'indiquer une adresse. Il n'y a pas la place d'y inscrire un <A HREF="04_software.php#intro">programme</A> entier.
</P>
<P>
L'UEFI est une variante plus moderne qui permet de préciser à quel endroit du <A HREF="07_disks.php#disque">disque dur</A>  trouver le <A HREF="02_boot.php#kernel">noyau</A> à lancer. Ainsi, on peut enregistrer <I>dans le réglage du micro-logiciel</I> plusieurs systèmes d'exploitations et choisir lequel démarrer par défaut.... Cela permet donc de se passer de chargeur de démarrage!
</P>
<P>
Dans le monde réel, quand le <A HREF="02_boot.php#bios">micro-logiciel</A> lance un <A HREF="02_boot.php#grub">chargeur de démarrage,</A> ce dernier vous propose en général, une interface de (configuration/choix du <A HREF="04_software.php#os">système d'exploitation</A> à booter), plus puissante, et plus agréable à utiliser et paramétrer. Ainsi, on peut vouloir laisser une entrée de secours dans le micro-logiciel, et installer quand même un chargeur de démarrage.
</P>
<P>
C'est même recommandé si vous avez des doutes, et que vous voulez pouvoir trafiquer les options du <A HREF="02_boot.php#kernel">noyau</A> facilement.
</P>
<P>
Pour fonctionner l'Uefi réclame une <A HREF="07_disks.php#partition">partition</A> à lui formatée en format fat32 que l'on appelle la <A HREF="07_disks.php#partition">partition</A> <B>EFI</B>. <I>(sans u)</I>
</P>

<A NAME="kernel"></A>
<H1>Le rôle du noyau</H1>

<P>
Si votre ordinateur sait se débrouiller à peu près avec vos différents périphériques, C'est par ce qu'il existe des interfaces de contrôles élémentaires entre les différents composants. Ainsi dès que vous mettez sous tension votre ordinateur, celui ci sait utiliser l'écran, par exemple. Vous remarquerez cependant que lors des premières phases du boot, l'écran n'affiche que du texte, ou une image en seize couleurs... Pourquoi? Les <A HREF="01_hardware.php#controler">contrôleurs</A> savent se mettre à disposition pour les opérations de base (Vesa par exemple est un standard de <A HREF="01_hardware.php#controler">contrôleur</A> graphique)...  Mais il faut connaitre intimement le <A HREF="01_hardware.php#controler">contrôleur</A> pour aller plus loin.
</P>
<P>
Le <A HREF="02_boot.php#bios">micro-logiciel</A> fournit une interface de base pour la communication entre les périphériques, mais celle ci est très limitée, et le <A HREF="02_boot.php#kernel">noyau</A> <A HREF="02_boot.php#bios">Linux</A> fait tout pour éviter d'en avoir besoin. Dans la pratique au contraire le <A HREF="02_boot.php#kernel">noyau</A> possède tout un tas de petits bouts de programmes (que l'on appelle des drivers sous Windows, et pilotes ou modules sous Linux) qui sont là pour l'aider reconnaitre et à tirer un plein profit des possibilité de chaque matériel.
</P>
<P>
À la suite du <A HREF="02_boot.php#boot">boot</A> avant que vous n'ayez lancé le programme, vous pouvez imaginer votre ordinateur comme contenant un zoo de <A HREF="02_boot.php#kernel">processus</A> qui attendent tous d'avoir quelque chose à faire. Ils attendent tous des événements. Un événement peut être le fait que vous appuyez sur une touche, ou que vous bougez la souris. Voir même que votre machine soit connectée à un réseau, et qu'un certain paquet de <A HREF="01_hardware.php#vocab">données</A> arrive de celui-ci.
</P>
<P>
Le <A HREF="02_boot.php#kernel">noyau</A> est un de ces processus. Mais il est spécial, car il contrôle ce que les autres <A HREF="02_boot.php#kernel">processus</A> utilisateurs effectuent, et il est normalement le seul <A HREF="02_boot.php#kernel">processus</A> autorisé à avoir un accès direct avec le matériel. Ainsi comme toutes les entrées sorties passent par lui, il peut planifier les opérations et empêcher que différents <A HREF="02_boot.php#kernel">processus</A> ne se gênent mutuellement.
</P>
<P>
Cependant certains <A HREF="02_boot.php#kernel">processus</A> sont autorisés à contourner cela, généralement en leur confiant un accès direct à un <A HREF="01_hardware.php#bus">bus</A> (l'audio professionnelle pour les temps de latence, et la <A HREF="01_hardware.php#cg">carte graphique</A> pour le jeux et les vidéos)
</P>
<P>
En fait, les <A HREF="02_boot.php#kernel">processus</A> utilisateurs, doivent faire une requête au <A HREF="02_boot.php#kernel">noyau</A> quand ils veulent obtenir les événements relatifs à votre clavier, afficher à l'écran, lire et écrire les disques, ou juste faire n'importe quoi d'autre que de balancer des bits dans la mémoire. Ces requêtes sont connues aussi le nom de system calls (appel systèmes).
</P>

<A NAME="grub"></A>
<H1>Le Chargeur de Démarrage</H1>

<P>
Le micro-logiciel, recherche à un emplacement déterminé qu'on appelle la table de partitions. Cette dernière est une section du <A HREF="07_disks.php#disque">disque dur</A>  située immédiatement à son début. La table des <A HREF="07_disks.php#partititxt2tagson">partitions</A> est normalisée, elle indique l'adresse du disque ou trouver le chargeur de démarrage.
</P>
<P>
Ce <A HREF="04_software.php#intro">programme</A> spécial (appelé le <A HREF="02_boot.php#boot">boot</A> loader, le <A HREF="02_boot.php#grub">chargeur de démarrage.</A> est placé dans la mémoire et démarré.
</P>
<P>
C'est lui qui charge le véritable système d'exploitation. Il réalise cela en cherchant un noyau, il le charge dans la mémoire, et le démarre.
</P>
<P>
Grub et le <A HREF="02_boot.php#grub">chargeur de démarrage</A> le plus connu de l'univers Linux, mais il n'est pas le seul. De nos jours le rôle du <A HREF="02_boot.php#grub">chargeur de démarrage</A> n'est plus aussi fondamental, grâce aux progrès des <A HREF="02_boot.php#bios">micro-logiciel</A> basés sur l'UEFI. En effet, ces derniers sont capables de charger directement le <A HREF="02_boot.php#kernel">noyau</A> du <A HREF="04_software.php#os">système d'exploitation</A> en mémoire.
</P>
<P>
Dans la pratique, un <A HREF="02_boot.php#grub">chargeur de démarrage</A> est souvent plus simple à configurer que le micro-logiciel, et offre une <A HREF="03_interface.php#ui">interface utilisateur</A> conviviale lors du <A HREF="02_boot.php#boot">boot</A> <I>(pour sélectionner un système d'exploitation, ou modifier des options <A HREF="01_hardware.php#vocab">données</A> au noyau)</I>.
</P>
<P>
Sachant alors que de nos jours, les besoin de ressources d'un <A HREF="02_boot.php#grub">chargeur de démarrage</A> sont faibles (une voir deux secondes lors du boot, et quelques mégaoctets d'espace disque), par commodité, on en installe un.
</P>

<A NAME="init"></A>
<H1>Le Gestionnaire d'initialisation</H1>

<A NAME="toc6"></A>
<H2>Init</H2>

<P>
Une fois le <A HREF="02_boot.php#kernel">noyau</A> chargé, celui-ci démarre le <A HREF="04_software.php#intro">programme</A> <CODE>init</CODE>
<CODE>init</CODE> est le premier logiciel à être lancé après le noyau. Ce sera son travail que de terminer le <A HREF="02_boot.php#boot">boot</A> jusqu'au login de l'utilisateur.
</P>
<P>
Il va se charger de lire les fichier de configuration. Il va rechercher les <A HREF="01_hardware.php#periph">périphériques</A> en place sur votre ordinateur. Il va monter les disques, lancer le serveur X. Bref, il va prendre soin de tout, jusqu'à ce que vous puissiez tranquillement entrer votre mot de passe et commencer à utiliser votre machine.
</P>
<P>
Et là encore, <CODE>init</CODE> ne va pas disparaitre, il restera en tache de fond, et sera le <A HREF="02_boot.php#kernel">processus</A> père de tous les autres... Le Tuer revient à arrêter le système (mais nous reviendrons là dessus). Il va ainsi rester en tâche de fond, et prendre soins de différents <I>services</I>.
</P>

<A NAME="systemd"></A>
<H2>Systemd</H2>

<P>
Init est le nom historique de ce programme, mais il existe de nombreux gestionnaire d'initialisation. Comme cependant, il ne peut y avoir qu'un seul <A HREF="02_boot.php#init">gestionnaire d'initialisation</A> par système d'exploitation, ce <A HREF="04_software.php#intro">programme</A> se placera toujours en <CODE>/bin/init</CODE>.
</P>
<P>
Je parlerai par la suite de <A HREF="02_boot.php#systemd">Systemd</A> car c'est le <A HREF="02_boot.php#init">gestionnaire d'initialisation</A> le plus courant. <I>(les spécialistes vont me clouer au pilori...)</I>
</P>

<A NAME="service"></A>
<H3>Les Services</H3>

<P>
Une fois que <A HREF="02_boot.php#systemd">Systemd</A> s'est initialisé lui même, il va lire ses différents fichiers de configuration, et, grâce à ces derniers, va lancer les différents <A HREF="02_boot.php#service">services</A> qui sont actifs sur la machine. Les <A HREF="02_boot.php#service">services</A> sont de programmes qui ont une tache précise et qui fournissent des interfaces pour faciliter ces dernières.
</P>
<P>
Les <A HREF="02_boot.php#service">services</A> qui font le mieux leur travail sont <I>transparents</I> en ce sens que l'on ne se doute pas de leur existence... Par exemple, vous espérez certainement que lors de l'insertion d'une clef usb, le <A HREF="04_software.php#os">système d'exploitation</A> la détecte et la fasse apparaitre quelque part <I>( Le Poste de travail sous Windows, ou le dossier <CODE>/media</CODE> sous Gnu-Linux ).</I>
</P>
<P>
Pour ce faire, il n'y a pas de secret, il faut qu'un <A HREF="04_software.php#intro">programme</A> vérifie toute les fractions de seconde si il y a eu une activité sur les ports usb de la machine! Il semble donc raisonnable d'espérer qu'un seul <A HREF="04_software.php#intro">programme</A> fasse cela, qu'il le fasse efficacement.
</P>
<P>
On voudra enfin que ce <A HREF="04_software.php#intro">programme</A> fournisse une interface pratique, afin que d'autre <A HREF="04_software.php#intro">programme</A> qui auraient besoin d'une ressource s'adresse au service et jamais à la ressource directement.
</P>
<P>
C'est le rôle des services, ils fournissent des couches d'abstraction qui rendent la gestion des différent programmes qui composent le <A HREF="04_software.php#os">système d'exploitation</A> plus agréable... Plus <I>administrable</I>
</P>

<A NAME="target"></A>
<H3>Les Targets</H3>

<P>
Désolé pour l'anglicisme, mais cette fois ci, y'a pas mieux... (çà veut dire «cible», mais çà ne se dit pas... je crois...)
</P>
<P>
On ne peut pas, on le devine, démarrer n'importe quels <A HREF="02_boot.php#service">services</A> dans n'importe quel ordre... Avant  de se connecter à Internet, il faut initialiser la carte réseaux... Avant de lancer la session de l'utilisateur, il faut monter les <A HREF="07_disks.php#partititxt2tagson">partitions</A> essentielles du système et régler la carte graphique. Le <A HREF="01_hardware.php#keyb">clavier</A> devra être dans la bonne langue avant que l'utilisateur entre son mot de passe....
</P>
<P>
On pourrait lancer les <A HREF="02_boot.php#kernel">processus</A> les uns après les autres, mais çà ne serait pas pratique pour la maintenance car à chaque installation de programme, le <A HREF="04_software.php#intro">programme</A> devrait savoir se trouve sa place au milieu des autres sans mettre trop la pagaille. Et le problème de l'initialisation séquentielle c'est que quand quelque chose déconne, çà prend des plombes, à démarrer.
</P>
<P>
Bref, <A HREF="02_boot.php#systemd">Systemd</A> a supplanté ses ancêtres pour ses capacités de parallélisation (entre autres). <A HREF="02_boot.php#systemd">Systemd</A> cherche à atteindre des targets. Une target c'est un ensemble de <A HREF="02_boot.php#service">services</A> qui rendent un système suffisamment  cohérent pour passer à l'assaut de la target suivante.
</P>
<P>
En gros, <A HREF="02_boot.php#systemd">Systemd</A> se lance. Il découvre que la target par défaut est un gestionnaire de connexion graphique. Cette target à besoin de la target 'multi-utilisateur' qui elle même a besoin de la target 'disques et <A HREF="07_disks.php#partititxt2tagson">partitions</A> locales' etc...
</P>
<P>
Puis target par target il lance tous les <A HREF="02_boot.php#service">services</A> nécessaire, <I>(et les <A HREF="02_boot.php#service">services</A> nécessaires aux services..)</I> attends que ceux ci en aient fini, et ainsi de suite jusqu'à n'avoir plus rien à faire.
</P>
<P>
Alors <A HREF="02_boot.php#systemd">Systemd</A> se range dans son coin et surveille que tout se passe bien. Parfois <A HREF="02_boot.php#systemd">Systemd</A> doit remettre l'ordre. Parfois, on demande à <A HREF="02_boot.php#systemd">Systemd</A> une nouvelle target qui peut être le redémarrage, l'arrêt, (ou autre). Mais dans tous les cas <A HREF="02_boot.php#systemd">Systemd</A> sera le dernier à quitter le navire, veillant tout arrêter dans le bon ordre.
</P>

<A NAME="target"></A>
<H3>Les Sockets</H3>

<P>
On ne peut pas encore entrer dans les sockets, car il n'y a pas lieu dans la section des fondamentaux. Il est cependant à savoir que les sockets sont les interfaces de communication des processus/programmes/services entre eux.
</P>
<P>
Il est de la responsabilité de <A HREF="02_boot.php#systemd">Systemd</A> de gérer les sockets.
</P>

<A NAME="login"></A>
<H1>Login as user</H1>

<P>
Les <A HREF="04_software.php#os">systèmes d'exploitation</A> basés sur Unix, (comme Gnu-Linux par exemple), sont <B>très</B> sécurisables (et pas forcément tous sécurisés...). Cela provient du fait qu'Unix a (dès le début) été pensé pour qu'il puisse fonctionner comme serveur d'université, et être partagé sur un réseau, faire face à de nombreuses requêtes simultanées...etc...
</P>
<P>
Le prix à payer pour que n'importe qui ne puisse s'accaparer toutes les ressources de la machines <I>(ni toucher aux fichiers de son voisin, ni introduire de virus...)</I> a été une gestion stricte des droits de chacun des utilisateurs. Et l'obligation faite à tous les utilisateur de posséder un « compte utilisateur » sur l'ordinateur, un compte associé à un « login », et un mot de passe.
</P>
<P>
Aussi les utilisateurs n'ont pas tous les droits sur la machine, il ne peuvent pas tout faire, et il existe par exemple de nombreux fichiers qui ne leurs sont pas accessibles.
</P>
<P>
Cette gestion, accompagnée par la <A HREF="06_unix.php#philo">philosophie Unix,</A>  est une des choses qui donnent sa puissance et sa stabilité aux environnements Gnu-Linux.
</P>

<A NAME="toc12"></A>
<H2>Interface texte et interface graphique</H2>

<P>
On peut démarrer des programmes de deux façons différents, soit à travers une interface graphique, soit à travers une interface textuelle.
</P>
<P>
Le <A HREF="02_boot.php#shell">shell</A> (coquillage en anglais), l'interface en mode texte, est appelé ainsi car il englobe et cache le <A HREF="02_boot.php#kernel">noyau</A> du système d'exploitation. C'est une caractéristique importante des <A HREF="04_software.php#os">systèmes d'exploitation</A> <A HREF="06_unix.php">Unix</A> et Gnu-Linux, que le <A HREF="02_boot.php#shell">shell</A> et le <A HREF="02_boot.php#kernel">noyau</A> soient des programmes bien séparés. Ainsi il est possible d'avoir différent shells, correspondant aux gouts de chacun. Le <A HREF="02_boot.php#shell">shell</A> et le <A HREF="02_boot.php#kernel">noyau</A> communiquent à travers un nombre limité d'appels système.
</P>
<P>
Quand vous vous connectez, vous vous identifiez à l'ordinateur. Sur les <A HREF="02_boot.php#bios">Linux</A> modernes, cela se passe généralement à travers un gestionnaire de connexion graphique. Mais il reste possible de passer sur des consoles virtuelles avec la séquence de touches Ctrl + Alt +F2 (ou F3, F4...), et de se connecter à travers l'interface texte.
</P>
<P>
Dans ce cas, un <A HREF="04_software.php#intro">programme</A> (traditionnellement <CODE>getty</CODE>) surveille le terminal, et appelle le <A HREF="04_software.php#intro">programme</A> <CODE>login</CODE>. Ainsi, vous vous identifiez soit au gestionnaire de connexion graphique, soit au <A HREF="04_software.php#intro">programme</A> <CODE>login</CODE> au moyen de votre nom d'utilisateur et de votre mot de passe. Ce nom d'utilisateur est vérifié dans un fichier appelé <CODE>/etc/passwd</CODE> qui est une séquence de lignes décrivant chacune un compte utilisateur.
</P>
<P>
Les mots de passe sont conservés dans un autre fichier chiffré <CODE>/etc/shadow</CODE> dont les autorisations d'accès sont plus restreintes. Lorsque vous entrez votre mot de passe, celui-ci est chiffré de la même façon et le <A HREF="04_software.php#intro">programme</A> <CODE>login</CODE> vérifie que les deux correspondent.
</P>
<P>
La sécurité de cette méthode repose sur le fait que s'il est facile de passer du mot de passe <I>en clair</I> à la version chiffrée, l'inverse est très difficile. Ainsi, même si quelqu'un pouvait voir la version codée de votre mot de passe, ils ne pourraient pas utiliser votre compte. Cela signifie également que si vous perdez votre mot de passe, il n'est pas de moyen de le récupérer, mais seulement de le changer pour quelque chose que vous choisirez <I>(plus judicieusement)</I>.
</P>

<A NAME="user"></A>
<H2>Utilisateurs et groupes</H2>

<P>
Une fois que vous êtes connectés, vous obtenez tous les réglages associés avec votre compte individuel. Vous pouvez également être reconnus comme membre d'un groupe. Un groupe est le nom donné à un ensemble d'utilisateurs qui possèdent des privilèges communs. Les groupes peuvent avoir des privilèges différents des privilèges de leurs membres. Les utilisateurs peuvent être membres de plusieurs groupes.
</P>
<P>
Pour donner un exemple simple, dans une entreprise, chaque utilisateur aura les privilèges nécessaires pour accéder à ses propres fichiers, mais sûrement pas au fichier des autres utilisateurs. Cependant, le groupe comptabilité, qui contiendra tous les membres de la comptabilité, pourra avoir un dossier commun, dans lequel seront stockées un ensemble de fichiers dont l'accès sera un des privilèges du groupe comptabilité. Les membres de la direction, feront probablement parti de différents groupes, si ce n'est pas la totalité.
</P>
<P>
Remarquez que, si l'on se réfère normalement aux utilisateurs et aux groupes par leur noms, ceux-ci sont stockés en interne par des identifiants numériques:
</P>

<UL>
<LI>Le fichier <CODE>/etc/passwd`</CODE> identifie votre nom d'utilisateur à un identifiant numérique.
<LI>Le fichier <CODE>/etc/groups`</CODE> réalise la même fonction avec les groupes.
</UL>

<P>
Les informations concernant votre compte incluent aussi votre répertoire personnel, (l'endroit où vous mettrez vos fichiers personnels). Enfin, la dernière information, concerne le shell, l'interpréteur de commande, c'est-à-dire le <A HREF="04_software.php#intro">programme</A> de devra lancer <CODE>login</CODE> une fois toutes les vérifications effectuées.
</P>

<A NAME="auth"></A>
<H2>With great power comes great responsibility</H2>

<P>
Il éxiste enfin un utilisateur particulier que l'on nomme le super-utilisateur, ou l'administrateur.
</P>
<P>
Cet utilisateur particulier a pour login <CODE>root</CODE>, et celui-ci possède tous les droits! <B>Tous!</B>
</P>
<P>
C'est un compte utilisateur qui est utilisé pour effectuer la maintenance du système. Il n'est pas prévu d'utiliser ce compte dans la vie courante. Le moindre virus lancé par cet utilisateur serait dévastateur... une application qui plante peut faire du mal! Aussi, démarrer une <A HREF="02_boot.php#login">interface graphique</A> au moyen de l'utilisateur root est le meilleur moyen de tous casser. //(je suis sérieux, je l'ai déjà fait!)
</P>
<P>
La commande <CODE>su Un_Nom_d_Utilisateur</CODE> permet de passer changer d'utilisateur.
La commande <CODE>su -</CODE> est équivalente à <CODE>su root</CODE> et permet de passer en mode root sur une <A HREF="02_boot.php#login">console</A> (graphique ou texte).
</P>
<P>
Le <A HREF="04_software.php#intro">programme</A> <CODE>sudo</CODE> permet de lancer la prochaine commande en mode super-utilisateur. Ce <A HREF="04_software.php#intro">programme</A> vérifiera que vous faites bien partie des utilisateur qui ont le droit de faire çà, vous demande votre mot de passe, et lance la commande comme si c'était le super-utilisateur qui l'avait fait...
</P>
<P>
Au passage, notez que certaines <A HREF="08_libre.php#distrib">distribution</A> de Gnu-Linux interdisent purement et simplement la connexion en tant que super-utilisateur (<I>Ubuntu</I>). Cependant, par défaut, les utilisateurs ont automatiquement l'accès à <CODE>sudo</CODE>, vous ne pouvez donc pas faire <CODE>su -</CODE> . La solution est alors de faire <CODE>sudo bash</CODE> pour lancer un <A HREF="02_boot.php#shell">shell</A> avec les privilèges super-utilisateur.
</P>
<P>
Aussi ce compte ne devrait être utilisé que pour la maintenance du système.
</P>

<A NAME="connected"></A>
<H1>Une fois connecté?</H1>

<P>
Ce qui arrive après dépend de comment vous avez fait les choses. Sur une <A HREF="02_boot.php#login">console</A> texte, login va lancer le <A HREF="04_software.php#intro">programme</A> défini comme interpréteur de commande, en mode graphique, l'environnement graphique va démarrer, et vous pourrez démarrer des programmes depuis celui-ci.
</P>

<A NAME="gui"></A>
<H2>Les Interfaces graphiques</H2>

<P>
Le <A HREF="04_software.php#os">système d'exploitation</A> Gnu-Linux à la particularité par rapport à Windows et MacOs de vous laisser libre de choisir l'interface graphique qui vous plait.
</P>
<P>
Sous d'autres systèmes d'exploitation, l'utilisateur est invité à personnaliser son environnement graphique à sa guise, mais il ne possède pas la liberté de modifier cette interface, de la remplacer par une autre...
</P>
<P>
Les <A HREF="02_boot.php#gui">interfaces graphiques</A> de Windows, Mac, et Android sont configurables dans une certaine mesure. Mais sous Gnu-Linux, il existe de très diverses <A HREF="02_boot.php#gui">interfaces graphiques</A> dont certaines peuvent être basées sur des concepts très différents les uns des autres.
</P>

<A NAME="toc17"></A>
<H3>Pour ne citer que les principales (et mes préférés)</H3>

<DL>
<DT>Kde</DT><DD>
possède une <A HREF="03_interface.php#ui">interface utilisateur</A> esthétique faite pour être facile d'accès pour les débutants
<P></P>
<DT>Gnome</DT><DD>
son grand concurrent en est à la version 3
<P></P>
<DT>Mate</DT><DD>
la descendante de Gnome 2, dont certains <I>(personne)</I> n'arrivaient pas à se défaire...
<P></P>
<DT>Xfce</DT><DD>
environnement complet (comme Kde et Gnome) destiné à des machines moins puissantes. Il est léger et réactif.
<P></P>
<DT>i3</DT><DD>
est destiné à des utilisateurs plus avancés qui veulent un système entièrement configurable, utilisable sans trop lever les mains du clavier, et très réactif.
</DL>

<A NAME="shell"></A>
<H2>Le Shell</H2>

<P>
Le <A HREF="02_boot.php#shell">shell</A> (<I>coquillage en anglais</I>) est appelé ainsi car il englobe cache le <A HREF="02_boot.php#kernel">noyau</A> du système d'exploitation.
</P>
<P>
C'est une caractéristique importante des <A HREF="04_software.php#os">systèmes d'exploitation</A> <A HREF="06_unix.php">Unix</A> et Linux, que le <A HREF="02_boot.php#shell">shell</A> et le <A HREF="02_boot.php#kernel">noyau</A> soient de programmes bien séparés. Ces deux programmes communiquent à travers un nombre limité d'appels système. Ainsi il est possible d'avoir différent shells, correspondant au gout de chacun.
</P>
<P>
Le <A HREF="02_boot.php#shell">shell</A> normal devrait vous afficher un symbole <CODE>$</CODE>, la prompte. Nous n'allons pour le moment pas rentrer dans les détails seulement de la ligne de commande, et de la syntaxe du shell. Intéressons nous plutôt à ce qu'il se passe du côté de l'ordinateur.
</P>
<P>
Le Shell n'est rien d'autre qu'un <A HREF="02_boot.php#kernel">processus</A> utilisateur, et même pas un qui soit véritablement extraordinaire. Il attend que vous appuyiez sur le clavier, en écoutant (à travers le noyau) le <A HREF="01_hardware.php#port">port</A> de communication de votre clavier. Le <A HREF="02_boot.php#kernel">noyau</A> voit les touches être pressées, et quand il reconnaît la touche entrée, il passe la ligne de texte à votre <A HREF="02_boot.php#shell">shell</A> tentera d'interpréter ces événements comme des commandes.
</P>

<A NAME="toc19"></A>
<H3>Les différents shells</H3>

<DL>
<DT>sh</DT><DD>
C'est l'ancêtre de tous, le premier à avoir été écrit. Il a été conservé pour des raisons de compatibilité jusqu'à devenir part incontournable du standard POSIX
<P></P>
<DT>Bash</DT><DD>
C'est le descendant de sh. Il l'améliore et l'étends tout en restant compatible avec son papa. Ce qui fait de lui le <A HREF="02_boot.php#shell">shell</A> pré installé par défaut sur <I>presque</I> toutes les <A HREF="08_libre.php#distrib">distribution</A> Linux
<P></P>
<DT>Zsh</DT><DD>
Un <A HREF="02_boot.php#shell">shell</A> moderne avec une auto-complétion puissante, de belles couleur qui le rendent lisible, même sans configuration préalable.
<P></P>
<DT>Fish</DT><DD>
Un <A HREF="02_boot.php#shell">shell</A> très pratique pour les débutants de la ligne de commande. Mais qui a une syntaxe parfois assez différente de Bash
</DL>

<HR NOSHADE SIZE=5>

<TABLE ALIGN="center" BORDER="1">
<TR>
<TD>PREC: <A HREF="01_hardware.html">Un ordinateur ?</A></TD>
<TD></TD>
<TD COLSPAN="2">SUIV: <A HREF="03_interface.html">Les Interfaces</A></TD>
</TR>
<TR>
<TD></TD>
<TD><A HREF="index.html">Menu Principal</A></TD>
<TD></TD>
</TR>
</TABLE>

<HR NOSHADE SIZE=5>

</DIV>
<!-- html code generated by txt2tags 2.6 (http://txt2tags.org) -->
<!-- cmdline: txt2tags 01_hardware.t2t.temp 02_boot.t2t.temp 03_interface.t2t.temp 04_software.t2t.temp 05_network.t2t.temp 06_unix.t2t.temp 07_disks.t2t.temp 08_libre.t2t.temp 09_shell.t2t.temp 10_console.t2t.temp 11_editor.t2t.temp 12_config.t2t.temp 13_help.t2t.temp 14_programming.t2t.temp 15_archlinux.t2t.temp 15_bashrc.t2t.temp author.t2t.temp bashrc_comment.t2t.temp index.t2t.temp roadmap.t2t.temp -->
</BODY></HTML>
-------------------------------------
Version Html, commentaires désactivés
-------------------------------------
