Un Ordinateur ?



%%toc




=La Préhistoire=


La Préhistoire c'est //grosso modo//, avant le 01 Janvier 1970...

On appelle cette date «l'epoch» (époque en français). Et depuis celle-ci, tous les ordinateurs qui fonctionnent sous un système d'exploitation de type Unix, battent la seconde à l'unisson...

==Vocabulaire Inutile==[Vocab]

**Réaliser une action** c'est agir pour changer la **situation actuelle** en une **nouvelle situation**.

Pour réaliser une opération mathématique, un humain réalise des calculs (**des instructions élémentaires**) sur des nombres (**des données d'entrée**) pour trouver un résultat (**des données de sortie**).

L'ordre et la manière de réaliser ces calculs (ces instructions) est nommé **l'algorithme** (la technique de calcul).

On va éclaircir par la suite...

==Le Boulier==[boulier]

On a inventé le boulier de calcul, et on peut faire plein de choses avec un boulier (addition, soustraction, noter un nombre...)

Mais le boulier a besoin d'un humain qui réalise des instructions sur les données... Il existe **5 instructions élémentaires** sur le boulier:

+ passer une boule de gauche à droite
+ passer une boule de droite à gauche
+ déplacer la main sur la ligne du dessus
+ déplacer la main sur la ligne du dessous
+ remettre à zéro (toutes les boules du même coté)


L'exemple du boulier fait bien ressortir la distinction qu'il existe **entre** __les instructions__ **et** __l'algorithme__... Connaitre les instructions ne sert à rien sans un algorithme pour leur donner une utilité.

On a aussi inventé le métier à tisser le fil... Avec, on fait des tapis, même si cela ne parait avoir que très peu à voir avec le boulier...

==La Machine À Calculer==[M_a_c]

Plus fort que les bouliers, on a inventé la machine à calculer. Un objet bien plus efficace que le boulier... On lui entre des nombres qui font bouger des mécanismes dans la machine. Et le mouvement des roues dentées, des machins et des bidules mécaniques font qu'on peut lire un résultat!

[[img/Calculator.jpg] https://fr.wikipedia.org/wiki/Calculatrice_m%C3%A9canique]
 | Machine à calculer Olivetti sans capot, 1964 ( credit Wikipedia )

Plus besoin d'un humain qui connait les détails de l'algorithme. La forme des rouages de la machine, leurs formes et leurs dispositions, c'est çà le véritable algorithme. Plus même besoin de connaitre les différentes instructions. (Sauf pour les techniciens!)

Cependant, ces première machines ne savaient réaliser qu'une seule opération (soit addition soit soustraction). Et à cet époque les machines doubles opérations étaient deux fois plus lourdes car elles comptaient deux fois plus de mécanique!

La machine à calculer pouvait, certes, effectuer différentes instructions, mais elle ne pouvait mettre en pratique qu'un seul algorithme...

Et une machine qui savait réaliser deux algorithmes différents, c'était //à peu près// deux machines dans une même carcasse!

Historiquement c'est peu de temps plus tard que l'on a commencer à programmer des métiers à tisser avec des cartes perforées. Ces cartes perforées, c'était la suite des instructions à réaliser pour obtenir tel ou tel motif sur le tissus. Vous faites le lien?

==La Machine de Turing==[m_d_turing]

On commence à se dire qu'un boulier multifonction programmable à la carte perforée...

Du coup... On a voulu inventer une machine calculer **universelle** qui sache effectuer n'importe quelle opération. Et cela malgré un nombre d'instruction restreint. En fonction d'un algorithme codé dans un support (comme une carte perforée) cette machine réaliserait  différentes instructions sur des données et obtiendrait le résultat voulu.

On aurait plus besoin de modifier **matériellement** la machine mais juste de remplacer la carte pour changer d'algorithme, et lui faire exécuter un autre programme.

Turing a imaginé et théoriser la machine de Turing. Celle-ci malgré un nombre d'instruction restreint peut simuler le fonctionnement de **n'importe quelle** machine à calculer classique. Ainsi, plus question d'inventer de machine à calculer nouvelle... Une seule machine de Turing peut toutes les remplacer, si on lui fournit le bon algorithme...

Je fais simple, mais c'est l'idée. Ne perdez pas le fil!

Aussi Turing a poursuivi son étude du sujet et a démontré qu'il existe des machines de Turing dites **universelles**. Celles-ci sont universelles quand elles sont capables de simuler le fonctionnement de n'importe quelle machine de Turing. Une seule machine de Turing universelle remplace n'importe quelle machine de Turing!

Alan Turing a été l'homme qui fait passer l'informatique de la recherche théorique sur les algorithmes, à de l'écriture de programmes.

[[img/turing.jpg] https://fr.wikipedia.org/wiki/Alan_Turing]
 | Alan Turing, ( credit Wikipedia )




=Anatomie De Base=


==L'Architecture De Von Neumann==[Von_neumann]

Comme la machine de Turing est une machine purement théorique, pour ce qui est de la réalisation pratique, l’architecture matérielle des ordinateurs modernes est basée sur ce que l'on appelle l'architecture de Von Neumann qui décompose l’ordinateur ainsi:

- Les **dispositifs d’entrées/sorties**, qui permettent de communiquer avec le monde extérieur.
  - (clavier, écran, imprimante...) de façon plus moderne, on parlera de //périphériques//

- L’**unité de contrôle**, qui est chargée du séquençage des opérations, du respect de l'algorithme
- L’**unité arithmétique et logique** (UAL) ou unité de traitement, qui effectue les instructions de base
  - Ces deux derniers correspondent à nos **processeurs** modernes.

- La **mémoire** qui contient les programmes et les données
  + mémoire de stockage (programmes et données de base de la machine, //les disques de données//)
  + mémoire vive (programmes et données en cours de fonctionnement, //La Ram//)

[[img/arch_von_neumann.png] https://fr.wikipedia.org/wiki/Architecture_de_von_Neumann]
 | Schémas de principe de l'architecture de Von Neumann ( credit Wikipedia )


==Une Architecture Matérielle==[Arch_materielle]

Il existe un algorithme capable de réaliser des additions //de tête//, comme il existe un algorithme pour faire des additions sur un boulier! Dans les deux cas le résultat est le même, pour ce qui est du résultat! Mais la réalisation pratique pour y parvenir est très différente!

Un algorithme mental ne peut pas être reproduit sur un boulier. Et de la même façon vous n'imaginez pas un boulier dans votre tête pour faire des additions.

Il existe un algorithme capable de réaliser de additions avec une machine de Turing. Une machine de Turing __universelle__ peut toujours reproduire le comportement d'une autre machine de Turin. (au besoin en la simulant!) Donc n'importe quelle machine de Turing universelle devrait pouvoir effectuer une addition...

Oui! Bien sur, mais pas en suivant le même programme! De la même façon qu'un algorithme valable au boulier n'est pas forcément exportable sur une calculatrice; un programme écrit pour une architecture matérielle n'est pas exportable sur une autre **architecture**.

On va y revenir...


==Les Ports==[Port]

Votre ordinateur possède à l'intérieur de lui un processeur qui réalise des instructions. Il possède une mémoire interne, appelée mémoire vive (ou juste ram). Le processeur et la mémoire vive se trouvent **physiquement** sur une carte électronique appelée "carte mère" qui est le cœur de votre ordinateur.

Votre ordinateur possède un écran et un clavier, il possède un disque dur, un lecteur de DVD, un lecteur de cartes sd...

Les différentes pièces de votre ordinateur sont toutes connectées par un port. Un port, c'est physiquement ce qui "porte" la connectique de l'appareil en question! Physiquement, c'est donc, ce dans quoi vous branchez vos périphériques. Les ports sont les autoroutes matérielles des données entre votre processeur, votre écran, votre disques et tout le reste.

==Un Bus==[Bus]

Le processeur, qui orchestre tout cela ne peut donc voir aucun des composants de l'ordinateur directement, il voit un **bus** qui peut prendre différentes valeurs numériques!

Un bus, c'est un la même chose qu'un port, mais du point de vue du processeur. C'est un port débarrassé de toutes les considération matérielles.

Imaginez un appareil simplisme! Le câble pour le brancher à l'ordinateur ne possède qu'un seul fil. S'il y a du courant électrique sur ce fil, l'ordinateur comprendra que c'est un UN. S'il n'y a pas de courant électrique sur ce fil, l'ordinateur comprendra que c'est un ZÉRO.

	- COURANT ou PAS DE COURANT, sont les états //physique// de ce port.

	- ZÉRO et UN, sont les valeurs numériques du bus.


==Ce Qui Est Vrai Quelque Soit L'Architecture==[Vrai]

Le seul composant dont la vitesse de fonctionnement est comparable à celle du processeur est la mémoire vive. Pour que les programmes puissent fonctionner, il faut qu'ils soient en mémoire.

Certains de ces appareils sont dirigés par des cartes contrôleurs que l'on branche sur la carte mère pour aider l'ordinateur à les piloter.

Quand votre ordinateur lit un programme ou une donnée depuis le disque, ce qui se passe en réalité, c'est que le processeur utilise en bus pour envoyer une requête de lecture au contrôleur du disque. Quelque temps après le contrôleur du disque utilise le bus pour envoyer  le signal au processeur qu'il a lu la donner et la placer à telle adresse de la mémoire. Le processeur peut ensuite utiliser le bus pour lire cette donnée.

Votre clavier et votre écran communique également avec le processeur moyen d'un bus, mais d'une façon plus simple. Nous en discuterons plus tard. Pour le moment nous en savons assez pour poursuivre.

==Les Architechtures Modernes==[Arch_moderne]

__Quelques remarques:__
- Une unité d'information binaire (ZÉRO ou UN) c'est un bit.
- La largeur du bus (mesurée en bits) détermine le nombre de valeurs que peuvent prendre un bus.
- La taille du bus qui relie le processeur à la carte mère est donc un déterminant essentiel d'un ordinateur.
- Dans la pratique, pour identifier une architecture matérielle, il suffit de donner le type de processeur.


L'architecture en 32 bits des processeur d'ordinateurs //grand publics// est appelée x86 à cause de ses différentes variantes (386,486,686...).

De nos jours la plupart des processeurs //d'ordinateur grand publics// se basent sur l'architecture x86_64 qui fonctionne en 64 bits. Les processeurs x86_64 sont vus comme des simples processeurs 64 bits s'ils sont utilisés par un système d'exploitation x86_64. Et sont vus comme un double processeur (dual core) par des systèmes d'exploitation 32 bits.

Les téléphones portables et les tablettes utilisent des processeur ARM (64 bits), qui sont plus économes en énergie que les x86 (32 ou 64 bits)

[[img/architecture.png] https://fr.wikipedia.org/wiki/Carte_m%C3%A8re]
 | Architecture "classique" d'une carte mère. ( credit Wikipedia )




=Les Périphériques=[Periph]


---------------------------------
Attention, on distingue:
- Périphériques __intégrés__ (comme le clavier d'un ordinateur portable, ou un composant soudé sur la carte mère d'un pc)
- Périphériques __externes__ (tous ceux qui sont amovible, ou que l'on peut débrancher)


-------------------------------

On entends par périphérique tout appareil que l'on peut "brancher" à l'ordinateur. Un clavier ou une souris, est des exemples de périphériques.

Le véritable cœur de votre ordinateur (l'unité de calcul), vous ne communiquerez jamais vraiment avec... C'est un composant électronique qui fonctionne en 5 volts et qui communique sur un bus de 64 bit... Il nous faut tout un équipement autour du processeur pour pouvoir tirer profit de ses capacités.

Mais quand bien même nous pourrions parler en binaire cinq volts haute fréquence avec une calculatrice de collégien, elle ne nous serait que de peu d'utilité avec son petit écran. On veut que la machine puisse s'exprimer, qu'elle fasse des choses... En bref, qu'elle puisse piloter des appareils (les périphériques)

Les périphériques sont les entrées et les sorties, ils sont ce qui fait que ceci est un ordinateur, un serveur, un téléphone, ou une calculette... Et non une théorique machine de Turing...




==Les Indispensables==[Indisp]

===La Carte Graphique===[Cg]

C'est ce qui va communiquer avec les écrans. Comme le traitement d'image en temps réel est une activité très gourmande en ressources, elle possède sa propre mémoire vive et son propre processeur (le GPU).

===La Carte Son===[Cs]

Même discours que pour la carte graphique, à la différence que de nos jours la puissance de calcul disponible est telle que //(pour la plupart des applications courantes, et donc pour la plupart des ordinateurs portables ou bas de gamme//) une petite puce électronique intégrée à la carte mère est suffisante.

===Une Mémoire De Stockage===[Masse]

Sans aucun programme à réaliser, un ordinateur ne fait rien...ou presque! On a besoin d'au moins un programme à lui donner.

Forcément, on aura besoin d'**au moins un** cd-rom, un dvd, une clef-usb, une carte sd, n'importe quoi... Ou se trouve **au moins un** programme....

Bon! Dans la pratique un support avec un système d'exploitation complet c'est mieux!

Et toujours dans la pratique si c'est un support sur lequel on peut lire... mais aussi écrire (pour y enregistrer des trucs, ou modifier nos programme), bein c'est encore mieux. Ainsi on préfèrera les disques durs (hdd) ou mémoire flash parallèles (ssd)

__Remarque:__Oui oui les ssd sont comme plusieurs cartes sd empilées

===Une Carte Réseau===[Net]

Une interface matérielle qui transforme des données en signal à émettre et un signal reçu en données.

: Modem
Carte réseau qui transforme des données en signal pour les réseaux téléphonique

: Carte Ethernet
Carte réseau qui transforme des données en signal pour les réseaux câblés

: Carte wifi
Carte réseau qui transforme des données en signal pour les réseaux sans fils


==Un Clavier==[Keyb]

Oui oui c'est un indispensable! Si le micro-logiciel n'arrive pas à trouver de clavier, il va bipper trois fois et va refuser de démarrer la machine! C'est comme çà, la souris, elle par contre est optionnelle.


==Les Moins Connus==[Moins_connu]

Il reste encore toute une panoplie:
- de contrôleurs (on y revient tout de suite)
- de périphériques de pointage (comme les tablettes tactiles, les écrans tactiles...)
- de lecteurs (de cartes, de disquette, cd, dvd...)
- des graveurs (cd, dvd-R, dvd+R)
- des récepteurs (radio, TV...)
- des webcam, un micro...
- et j'en passe..



===La Dicrete Card===[Discrete_card]

Mais il y en a un qu'il faut comprendre car il peut être source de confusion...

De nos jours les ordinateurs portable en on souvent deux cartes graphiques, une qui est dite "intégrée" et l'autre dite "discrète". Cette dernière est //théoriquement// plus puissante, mais elle est aussi plus consommatrice d'électricité.

(J'ai écrit "théoriquement" car souvent, la discrete card ne possède pas sa propre mémoire vive, elle l'emprunte au processeur.

Ainsi, suivant votre configuration, elle démarrera quand vous brancherez un second écran, ou quand l'ordinateur est en charge... Parfois elle se configure dans le bios, parfois pas... Parfois le système d'exploitation gère tellement mieux l'une que l'autre que voilà... Dans ces cas faut bidouiller...


=Interruptions Système=[Interrupts]



Votre clavier est un périphérique très simple, il est simple car il génère une petite quantité de données et lentement (selon les standards d'un ordinateur). Quand vous appuyez ou relâchez une touche, cet événement est signalé à travers le fil du clavier. La valeur d'un bus change et déclenche ce qu'on appelle une interruption matérielle.

C'est le travail de système d'exploitation de surveiller de telles interruptions. Pour chaque cas possible d'interruption, il y aura un gestionnaire d'interruption, un composant du système d'exploitation qui consigne les données associées à cette interruption jusqu'à ce qu'elle puisse être traitée.

N'importe quel type d'interruption est associée à un niveau de priorité. Les interruptions de base priorité (comme les événements du clavier) devront attendre le traitement des processus de haute priorité (comme les événements de disque dur).

C'est la capacité du système d'exploitation à savoir correctement prioriser les interruptions qui rend ce système stable et réactif. Et c'est un des gros point fort de Linux, qui font de lui la norme dans le monde des serveurs.

Une des interruptions système les plus importante est l'horloge. Elle empêche qu'un seul programme qui plante ne s'accapare l'ordinateur. A chaque fois qu'elle intervient, le système d'exploitation reprends la main et réactualise ses priorités.


=Les Contrôleurs=[Controler]


==L'Idée==[Controler_idee]

En Informatique, on appelle un Contrôleur, une puce électronique qui fournit une interface entre un périphérique et une carte mère.

Par exemple votre écran doit pourvoir afficher différentes résolutions (niveau de détail de l'affichage), et cependant, certaines résolutions incorrectes pourraient l'endommager...

Le Contrôleur est là pour détecter un ordre de changer de résolution, et ne pas le transmettre à l'écran si cet ordre est invalide !

Un Contrôleur, c'est une puce électronique qui fonctionne à des vitesses comparables à celle des processeurs, mais qui sait se mettre à la vitesse de ceux qu'elle contrôle.

==Exemple Avec Un Disque Dur==[Controler_dd]

(Pour les besoins de la démonstration imaginez votre disque dur comme un lecteur de disque vinyle! Il faut lever la tête de lecture avant de la déplacer sous peine de rayer le disque! Et on éteindra le moteur et on remettra la tête dur à l'origine/ sur son reposoir avant d'éteindre le moteur)

Donc:
- Le processeur envoi une demande de lecture d'un fichier.
- Le Contrôleur répond qu'il a comprit la requête.
- Le Contrôleur vérifie que la tête de lecture n'est pas déjà en train de lire quelque chose ailleurs, et attend si besoin.
- Si la tête de lecture est disponible, il va traduire la requête:
 - LÈVE LA TÊTE DE LECTURE
  - OK, c'est fait! Répond le disque.
- Le processeur envoi une autre requête de lecture.
- Le Contrôleur répond qu'il est trop occupé pour le moment mais qu'il le place dans sa liste des choses à faire
 - DÉPLACE LA TÊTE A CET ENDROIT
  - OK, c'est fait!
 - DESCEND LA TÊTE ET LIT
  - bla bla bla bla bla.
 - OK J'AI EU CE QUE JE VOULAIS ARRÊTE DE LIRE
- Le contrôleur commence à envoyer les données là ou on lui a demandé.
 - RELÈVE LA TÊTE
  - OK, c'est fait!
 - DÉPLACE LA TÊTE A CET ENDROIT (on a encore du travail...)
  - ok j'y suis !
 - DESCEND LA TÊTE ET LIT
  - bla bla bla bla bla.
 - OK J'AI EU CE QUE JE VOULAIS
- Le contrôleur commence à envoyer les données là ou on lui a demandé.
 - RELÈVE LA TÊTE
  - ok, c'est fait!
- Le processeur signal qu'il n'a rien d'autre à demander
 - RANGE TA TÊTE A L'ORIGINE
  - ok j'y suis !
 - ÉTEINTS LE MOTEUR


Bien entendu les choses sont plus complexes, les disques durs sont un goulot d'étranglement de l'ordinateur... Et en voyant à quel point les choses deviennent embrouillées en quelques ligne, on devine l'utilité du Contrôleur!

Programmer deux composants très différents avec des vitesses de fonctionnement très différentes pour qu'ils travaillent ensemble est un casse-tête... On préfèrera fabriquer:

- d'un coté, un disque dur qui fonctionne comme les ingénieurs des disques décident.
- de l'autre, un processeur qui fonctionne comme les ingénieurs des processeurs décident.


Et au milieu un Contrôleur nous donnera juste le un niveau d'abstraction nécessaire pour nous simplifier la vie.

Aussi, pour la qualité et le sérieux de cette page, arrêtez désormais d'imaginer votre disque dur comme un disque vinyle! Vous remarquerez que la discussion entre le contrôleur et le processeur n'a pas de raison de changer pour autant!

Remarquez d'ailleurs qu'il pourrait bien y avoir une armée de tailleurs de pierre derrière le contrôleur... Çà ne changerai rien du point de vue du processeur!

C'est l'intérêt des **niveaux d'abstraction**. Une notion fondamentale pour la programmation des logiciels! Retenez ce terme, vous le retrouverez bientôt.

Pour charger tous ces niveaux d'abstraction, et passer du tas inerte d'électronique à l'ordinateur fonctionnel, on procède au boot. Le démarrage de l'ordinateur!

Vous êtes en principe armé pour passer à la suite....
